/*
 * Copyright (c) 2009, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *  * Neither the name of Google, Inc. nor the names of its contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#define LOG_TAG "tboot"

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/input.h>
#include <pthread.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/mount.h>
#include <sys/utsname.h>

#include "tboot_ui.h"
#include "diskconfig/diskconfig.h"
#include "platform.h"
#include "cutils/hashmap.h"
#include "cutils/config_parser.h"
#include "tboot_util.h"
#include "tboot.h"
#include "fastboot.h"
#include "debug.h"
#include "fstab.h"
#include "battery.h"
#include "charging.h"
#include "uevent.h"

/* Generated by the makefile, this function defines the
 * RegisterDeviceExtensions() function, which calls all the
 * registration functions for device-specific extensions. */
//#include "register.inc"

/* NOTE: tboot uses two sources of information about the disk. There
 * is disk_layout.conf which specifies the physical partition layout on
 * the disk via libdiskconfig. There is also preos.fstab which gives
 * detail on the filesystems associates with these partitions, see fstab.c.
 * The device node is used to link these two sources when necessary; the
 * 'name' fields are typically not the same.
 *
 * It would be best to have this in a single data store, but we wanted to
 * leverage existing android mechanisms whenever possible, there are already
 * too many different places in the build where filesystem data is recorded.
 * So there is a little bit of ugly gymnastics involved when both sources
 * need to be used.
 */

/* libdiskconfig data structure representing the intended layout of the
 * internal disk, as read from /etc/disk_layout.conf */
struct disk_info *disk_info;

/* Synchronize operations which touch EMMC. Fastboot holds this any time it
 * executes a command. Threads which touch the disk should do likewise. */
pthread_mutex_t action_mutex = PTHREAD_MUTEX_INITIALIZER;

/* Not bothering with concurrency control as this is just a flag
 * that gets cleared */
static int autoboot_enabled;

/* power key pressed when auto boot countdown */
static int power_pressed = 0;

/* Whether to kexec into a 2nd-stage kernel on boot */
static int g_use_autoboot = 0;

/* Filesystem containing 2nd-stage boot images */
static char *g_2ndstageboot_part = PLATFORM_PTN;

/* Directory within filesystem containing 2nd-stage boot images */
static char *g_2ndstageboot_dir = "boot";

/* When performing a countdown, how many seconds to wait */
static int g_autoboot_delay_secs = 8;

/* Default size of memory buffer for image data */
static int g_scratch_size = 10;

/* If nonzero, wait for "fastboot continue" before applying a
 * detected SW update in try_update_sw() */
static int g_update_pause = 0;

char *g_update_location = NULL;

/* ignore key press when provisioning */
static int ignore_keypress = 0;

int enable_keypress(void)
{
	ignore_keypress = 0;
}

int disable_keypress(void)
{
	ignore_keypress = 1;
}

#define AUTO_UPDATE_FNAME	DEVICE_NAME ".auto-ota.zip"

int (*platform_provision_function)(void);

void set_platform_provision_function(int (*fn)(void))
{
	platform_provision_function = fn;
}

/* Set up a specific partition in preparation for auto-update The source_device
 * is the partition that the update is stored on; if it's the same
 * as the partition that we're performing this routine on, verify its
 * integrity and resize it instead of formatting.
 *
 * Note that erase_partition does a 'quick' format; the disk is not zeroed
 * out. */
static int provision_partition(const char *name, Volume *source_volume)
{
	struct part_info *ptn;
	char *device = NULL;
	int ret = -1;

	/* Set up cache partition */
	ptn = find_part(disk_info, name);
	if (!ptn) {
		pr_error("Couldn't find %s partition. Is your "
				"disk_layout.conf valid?\n", name);
		goto out;
	}
	device = find_part_device(disk_info, ptn->name);
	if (!device) {
		pr_error("Can't get %s partition device node!\n", name);
		goto out;
	}
	/* Not checking device2; if people are declaring multiple devices
	 * for cache and data, they're nuts */
	if (!strcmp(source_volume->device, device)) {
		if (ext4_filesystem_checks(device)) {
			pr_error("%s filesystem corrupted.\n", name);
			goto out;
		}
	} else {
		if (erase_partition(ptn)) {
			pr_error("Couldn't format %s partition.\n", name);
			goto out;
		}
	}

	ret = 0;
out:
	free(device);
	return ret;
}

/* Ensure the device's disk is set up in a sane way, such that it's possible
 * to apply a full OTA update */
static int provisioning_checks(Volume *source_device)
{
	pr_debug("Preparing device for provisioning...\n");

	if (platform_provision_function && platform_provision_function()) {
		pr_error("Platform-speciifc provision function failed.\n");
		return -1;
	}

	if (provision_partition(CACHE_PTN, source_device)) {
		return -1;
	}

	if (provision_partition(DATA_PTN, source_device)) {
		return -1;
	}

	return 0;
}

/* Check a particular volume to see if there is an automatic OTA
 * package present on it, and if so, return a path which can be
 * fed to the command line of the recovery console.
 *
 * Don't report errors if we can't mount the volume or the
 * auto-ota file doesn't exist. */
static char *detect_sw_update(Volume *vol)
{
	char *filename = NULL;
	struct stat statbuf;
	char *ret = NULL;
	char *mountpoint = NULL;

	if (asprintf(&mountpoint, "/mnt%s", vol->mount_point) < 0) {
		pr_perror("asprintf");
		die();
	}

	if (asprintf(&filename, "%s/" AUTO_UPDATE_FNAME,
				mountpoint) < 0) {
		pr_perror("asprintf");
		die();
	}
	pr_debug("Looking for %s...\n", filename);

	if (mount_partition_device(vol->device, vol->fs_type,
			mountpoint)) {
		if (!vol->device2 || mount_partition_device(vol->device2,
				vol->fs_type, mountpoint))
		{
			pr_debug("Couldn't mount %s.\n", vol->mount_point);
			goto out;
		}
	}

	if (stat(filename, &statbuf)) {
		if (errno == ENOENT)
			pr_debug("Coudln't find %s.\n", filename);
		else
			pr_perror("stat");
	} else {
		ret = strdup(filename + 4); /* Nip off leading '/mnt' */
		if (!ret) {
			pr_perror("strdup");
			die();
		}
		pr_info("OTA Update package found: %s.\n", filename);
	}
out:
	free(filename);
	umount(mountpoint);
	free(mountpoint);
	return ret;
}

void disable_autoboot(void)
{
	if (autoboot_enabled) {
		autoboot_enabled = 0;
		pr_info("Countdown disabled.\n");
	}
}

static int countdown(char *action, int seconds)
{
	int ret;
	int frag;
	int total;
	autoboot_enabled = 1;

	if (seconds <= 0)
		return autoboot_enabled;
	if (seconds > 100)
		seconds = 100;

	total = seconds;
	/*
	 * round to integer small than float number
	 * we are safe because of seconds value range
	 */
	frag = (int)((-100.0) / total - 0.5);
	pr_info("Press a button to cancel this countdown\n");
	for ( ; seconds && autoboot_enabled && !power_pressed; seconds--) {
		pr_info("Press any key to cancel %s...%d\n", action, seconds);
		tboot_ui_textbar(frag * seconds, "Power to %s,"
				" other keys to cancel...%d",
				action, seconds);
		sleep(1);
	}
	tboot_ui_hidebar("");
	ret = autoboot_enabled;
	autoboot_enabled = 0;
	return ret;
}

int try_update_sw(Volume *vol, int use_countdown)
{
	int ret = 0;
	char *update_location;

	/* Check if we've already been here */
	if (g_update_location)
		return 0;

	update_location = detect_sw_update(vol);
	if (!update_location)
		return 0;

	if (use_countdown) {
		int countdown_complete;
		countdown_complete = countdown("SW update",
				g_autoboot_delay_secs);
		if (!countdown_complete) {
			tboot_ui_hidebar("SW update canceled.");
			free(update_location);
			return 0;
		}
	}

	ret = -1;

	pthread_mutex_lock(&action_mutex);
	tboot_ui_bouncebar("Performimg SW update...");
	if (provisioning_checks(vol)) {
		free(update_location);
	} else {
		if (!g_update_pause) {
			apply_sw_update(update_location, 0);
			free(update_location);
		} else {
			/* Stash the location for later use with
			 * 'fastboot continue' */
			g_update_location = update_location;
			ret = 0;
		}
	}
	tboot_ui_hidebar("");
	pthread_mutex_unlock(&action_mutex);
	return ret;
}

static int autoboot_precheck(const char *kernel)
{
	char file[PATH_MAX];
	char *bak;
	int fd;

	char basepath[PATH_MAX];
	snprintf(basepath, sizeof(basepath), "/mnt/%s/%s/",
			g_2ndstageboot_part, g_2ndstageboot_dir);

	/* check if we're boot 2nd bak kernel */
	bak = strstr(kernel, ".bak");

	/* check all files needed */
	snprintf(file, sizeof(file), "%s/cmdline%s", basepath,
		 bak ? bak : "");
	if (access(file, R_OK)) {
		pr_error("%s: access file %s failed: %s\n", __func__,
			 file, strerror(errno));
		return -1;
	}
	snprintf(file, sizeof(file), "%s/%s", basepath, kernel);
	if (access(file, R_OK)) {
		pr_error("%s: access file %s failed: %s\n", __func__,
			 file, strerror(errno));
		return -1;
	}
	return 0;
}

static int start_default_kernel(void);
static void *autoboot_thread(void *arg)
{
	if (!countdown("boot", g_autoboot_delay_secs)) {
		tboot_ui_warn("Boot canceled, back to Pre-OS mode.");
		return NULL;
	}

	return (void *)start_default_kernel();
}

static int input_callback(int fd, short revents, void *data)
{
	struct input_event ev;
	int ret;

	ret = ev_get_input(fd, revents, &ev);
	if (ret)
		return -1;

	pr_verbose("Event type: %x, code: %x, value: %x\n",
				ev.type, ev.code,
				ev.value);

	/* ignore key press when provisioning */
	if (ignore_keypress)
		return 0;

	/*
	 * press power to boot selected kernel immediately
	 * press other keys to cancel boot
	 */
	if (autoboot_enabled && ev.type == EV_KEY) {
		if (ev.code == KEY_POWER)
			power_pressed = 1;
		else
			disable_autoboot();

		return 0;
	}

	/*
	 * handle VOLUMEUP, VOLUMEDOWN, POWER press event for rendering menu
	 * and we don't care repeat key event (ev.value == 2)
	 */
	if (ev.type == EV_KEY && ev.value == 1) {
		if (ev.code == KEY_VOLUMEUP || ev.code == KEY_VOLUMEDOWN ||
				ev.code == KEY_POWER) {
			RESET_ALARM;
			if (lcd_state != lcd_state_on) {
				/* do and only do light on LCD */
				lcd_state = (lcd_state_t)lcd_state(LCD_KEY);
				return 0;
			}
		}

		if (ev.code == KEY_VOLUMEUP)
			tboot_ui_menu_up();
		else if (ev.code == KEY_VOLUMEDOWN)
			tboot_ui_menu_down();
		else if (ev.code == KEY_POWER)
			tboot_ui_menu_action();
		else
			pr_debug("unkown key pressed.\n");
	}

	return 0;
}


static void *input_listener_thread(void *arg)
{
	pr_verbose("begin input listener thread\n");

	while (1) {
		if (!ev_wait(-1))
			ev_dispatch();
	}
	pr_verbose("exit input listener thread\n");

	return NULL;
}


void start_kernel(const char *kernel)
{
	char basepath[PATH_MAX];
	int ret;

	tboot_ui_bouncebar("Booting %s...", kernel);
	/* wait a second for display */
	sleep(1);
	if (autoboot_precheck(kernel)) {
		pr_debug("precheck for kernel failed\n");
		tboot_ui_error("Missing kernel or cmdline.");
		power_pressed = 0;
		return;
	}
	/* partition has already mounted by precheck */
	snprintf(basepath, sizeof(basepath), "/mnt/%s/%s/",
			g_2ndstageboot_part, g_2ndstageboot_dir);
	kexec_linux(basepath, kernel);

	/* Failed if we get here */
	pr_error("kexec failed\n");
	tboot_ui_error("Boot failed, back to Pre-OS mode.");
	power_pressed = 0;
}


/*
 * menu handlers
 */
static int mount_internal_mmc(void)
{
	struct part_info *autoboot_ptn;

	/* Mount partition for kexec */
	autoboot_ptn = find_part(disk_info, g_2ndstageboot_part);
	if (mount_partition(autoboot_ptn)) {
		pr_error("Can't mount second-stage boot partition (%s)\n",
				g_2ndstageboot_part);
		return -1;
	}

	return 0;
}

static int start_default_kernel(void)
{
	char target[PATH_MAX];

	if (!mount_internal_mmc())
		start_kernel("kernel");
	else
		tboot_ui_error("Mount rootfs failed.");

	/* start kernel failed. */
	snprintf(target, sizeof(target), "/mnt/%s", g_2ndstageboot_part);
	return umount(target);
}

static int start_backup_kernel(void)
{
	char target[PATH_MAX];

	if (!mount_internal_mmc())
		start_kernel("kernel.bak");
	else
		tboot_ui_error("Mount rootfs failed.");

	/* start kernel failed. */
	snprintf(target, sizeof(target), "/mnt/%s", g_2ndstageboot_part);
	return umount(target);
}

/*
 * mount external rootfs to /mnt/g_2ndstageboot_part
 * external rootfs device specified by config key word
 * rootfs.
 */
static int mount_external_mmc(void)
{
	int ret;
	char *rootfs;
	char target[PATH_MAX];

	if (snprintf(target, sizeof(target), "/mnt/%s", g_2ndstageboot_part) < 0) {
		pr_error("snprintf failed.\n");
		return -1;
	}

	if (mkdir(target, S_IRWXU | S_IRWXG | S_IRWXO) == -1) {
		if (errno != EEXIST) {
			pr_error("Failed to create mount point.\n");
			return -1;
		}
	}

	rootfs = tboot_config_get(ROOTFS_KEY);
	if (!rootfs) {
		pr_error("Invalid tboot config rootfs.\n");
		return -1;
	}

	ret = mount(rootfs, target, "ext4", 0, NULL);
	if (ret == -1)
		pr_error("Mount failed: %s\n", strerror(errno));

	return ret;
}

static int start_mmc_kernel(void)
{
	char target[PATH_MAX];

	if (!mount_external_mmc())
		start_kernel("kernel");
	else
		tboot_ui_error("Mount rootfs failed.");

	/* start kernel failed. */
	snprintf(target, sizeof(target), "/mnt/%s", g_2ndstageboot_part);
	return umount(target);
}

/*
 * mount NFS rootfs to /mnt/g_2ndstageboot_part. NFS URL specified by config
 * key word "nfsurl", e.g.:
 *	nfsurl = 192.168.100.2:/home/nfs
 */
static int mount_nfs(void)
{
	int ret;
	char *rootfs;
	char target[PATH_MAX];

	if (snprintf(target, sizeof(target), "/mnt/%s", g_2ndstageboot_part) < 0) {
		pr_error("snprintf failed.\n");
		return -1;
	}

	if (mkdir(target, S_IRWXU | S_IRWXG | S_IRWXO) == -1) {
		if (errno != EEXIST) {
			pr_error("Failed to create mount point.\n");
			return -1;
		}
	}

	rootfs = tboot_config_get(NFSURL_KEY);
	if (!rootfs) {
		pr_error("Invalid tboot config rootfs.\n");
		return -1;
	}

	ret = execute_command("/bin/nfsmount %s %s", rootfs, target);
	if (ret < 0) {
		pr_error("could not mount nfsroot.\n");
		return -1;
	}

	return ret;
}

static int start_nfs_kernel(void)
{
	char target[PATH_MAX];

	if (!mount_nfs())
		start_kernel("kernel");
	else
		tboot_ui_error("Mount rootfs failed.");

	/* start kernel failed. */
	snprintf(target, sizeof(target), "/mnt/%s", g_2ndstageboot_part);
	return umount(target);
}

void setup_disk_information(char *disk_layout_location)
{
	char *disk_force;
	/* Read the preos.fstab, which is used to for filesystem
	 * meta-data and also the sd card device node */
	load_volume_table();

	/*
	 * If all device nodes exist and disk_force set to no in
	 * config file, skip to load/write partition table
	 */
	disk_force = tboot_config_get(DISK_FORCE_KEY);
	if (!disk_force) {
		pr_error("Invalid tboot config disk_force.\n");
		tboot_config_set(DISK_FORCE_KEY, "yes");
	}

	if (!check_devnodes() && !strcasecmp(disk_force, "no")) {
		pr_debug("bypass load disk config\n");
		return;
	}

	/* Read disk_layout.conf, which provides physical partition
	 * layout information */
	pr_debug("Reading disk layout from %s\n", disk_layout_location);
	disk_info = load_diskconfig(disk_layout_location, NULL);
	if (!disk_info) {
		pr_error("Disk layout unreadable.\n");
		die();
	}
	process_disk_config(disk_info);
	dump_disk_config(disk_info);

	/* Set up the partition table */
	if (apply_disk_config(disk_info, 0)) {
		pr_error("Couldn't apply disk configuration.\n");
		die();
	}
}


static void parse_cmdline_option(char *name)
{
	char *value = strchr(name, '=');

	if (value == 0)
		return;
	*value++ = 0;
	if (*name == 0)
		return;

	if (!strncmp(name, "tboot", 5))
		pr_info("Got parameter %s = %s\n", name, value);
	else
		return;

	if (!strcmp(name, "tboot.bootloader")) {
		g_use_autoboot = atoi(value);
	} else if (!strcmp(name, "tboot.delay")) {
		g_autoboot_delay_secs = atoi(value);
	} else if (!strcmp(name, "tboot.scratch")) {
		g_scratch_size = atoi(value);
	} else if (!strcmp(name, "tboot.bootpart")) {
		g_2ndstageboot_part = strdup(value);
		if (!g_2ndstageboot_part)
			die();
	} else if (!strcmp(name, "tboot.bootdir")) {
		g_2ndstageboot_part = strdup(value);
		if (!g_2ndstageboot_part)
			die();
	} else if (!strcmp(name, "tboot.updatepause")) {
		g_update_pause = atoi(value);
	} else if (!strcmp(name, "tboot.platform")) {
		if (!strncmp(value, "blackbay", 8))
			set_current_platform(PLATFORM_BLACKBAY);
		else if (!strncmp(value, "redridge", 8))
			set_current_platform(PLATFORM_REDRIDGE);
		else if (!strncmp(value, "redhookbay", 10))
			set_current_platform(PLATFORM_REDHOOKBAY);
		else
			set_current_platform(PLATFORM_UNKNOWN);
	} else {
		pr_error("Unknown parameter %s, ignoring\n", name);
	}
}

char preos_version[PREOS_VERSION_LEN];
static void get_preos_version(const char *file)
{
	const char *path = PREOS_VERSION_LOCATION;
	char *pchr;
	int ret;
	int fd;

	if (file)
		path = file;
	fd = open(path, O_RDONLY);
	if (fd < 0) {
		pr_error("open %s failed\n", path);
		return;
	}
	ret = read(fd, preos_version, PREOS_VERSION_LEN);
	if (ret < 0) {
		pr_error("read file failed\n");
		close(fd);
		return;
	}
	close(fd);
	pchr = strchr(preos_version, '\n');
	if (pchr)
		*pchr = 0;
}

extern void *uevent_thread(void *arg);

/* current firmware versions on board, published by fastboot */
static char fw_versions[16];
static char ker_version[64];
static void display_sysinfo(int no_ui)
{
	struct utsname kernel;

	get_preos_version(NULL);

	if (!uname(&kernel))
		snprintf(ker_version, sizeof(ker_version), "%s %s",
				kernel.sysname, kernel.release);
	else
		snprintf(ker_version, sizeof(ker_version), "Unknown");

	if (!tboot_plugin_get_fw_rev(fw_versions, sizeof(fw_versions)))
		snprintf(fw_versions, sizeof(fw_versions), "Unknown");

	if (!no_ui) {
		tboot_ui_sysinfo("Pre-OS v%s", preos_version);
		tboot_ui_sysinfo("IFWI %s | %s", fw_versions, ker_version);
	}

	pr_info("Kernel version: %s\n", ker_version);

	fastboot_publish("product", DEVICE_NAME);
	fastboot_publish("kernel", ker_version);
	fastboot_publish("preos", preos_version);
	fastboot_publish("ifwi", fw_versions);
}

/*
 * call back function to update tboot UI
 */
static void ui_callback(void *arg)
{
	char buf_usb[32];
	char buf_charger[32];
	char buf_bat[32];
	int status;
	static saved_usb_status = STATUS_UNKOWN;
	static saved_charger_status = STATUS_UNKOWN;

	status = usb_status();
	if (status == STATUS_UNKOWN)
		snprintf(buf_usb, sizeof(buf_usb), "USB: Unknow");
	else
		snprintf(buf_usb, sizeof(buf_usb), "USB: %s",
				status == STATUS_CONNECTED ?
				"connected" : "disconnected");
	if (saved_usb_status != status) {
		RESET_ALARM;
		lcd_state = (lcd_state_t)lcd_state(LCD_USB_EVENT);
		saved_usb_status = status;
	}

	status = charger_status();
	if (status == STATUS_UNKOWN)
		snprintf(buf_charger, sizeof(buf_charger), "Charger: Unknow");
	else
		snprintf(buf_charger, sizeof(buf_charger), "Charger: %s",
				status == STATUS_CONNECTED ?
				"connected" : "disconnected");
	if (saved_charger_status != status) {
		RESET_ALARM;
		lcd_state = (lcd_state_t)lcd_state(LCD_USB_EVENT);
		saved_charger_status = status;
	}

	status = battery_capacity();
	if (status < 0)
		snprintf(buf_bat, sizeof(buf_bat), "Battery: Unknow");
	else
		snprintf(buf_bat, sizeof(buf_bat), "Battery: %d%%", status);

	tboot_ui_uevent("%s, %s, %s", buf_usb, buf_charger, buf_bat);
}

/*
 * check battery capacity
 */
int check_battery(void)
{
	int bat_threshold;

	bat_threshold = atoi(tboot_config_get(BAT_THRESHOLD_KEY));
	if (bat_threshold < 0 || bat_threshold > 100)
		pr_warning("you set battery threshold to %d, is that right?\n", bat_threshold);

	if (battery_capacity() < bat_threshold) {
		pr_debug("battery is too low, lower than %d\n", bat_threshold);
		return -1;
	}
	return 0;
}

#define TBOOT_CONFIG "/etc/preos/preos.conf"

/* tboot config default values */
#define UI_CONF_VALUE 0 // NULL pointer
#define DISK_CONFIG_VALUE "/etc/disk_layout.conf"
#define PUSH_DIR_VALUE "/tmp"
#define ROOTFS_VALUE "/dev/mmcblk1"
#define ENABLE_NFS_VALUE "no"
#define NFSURL_VALUE "192.168.100.2:/home/nfs"
#define DISK_FORCE_VALUE "yes"
#define BAT_THRESHOLD_VALUE "10"
#define LCD_DIM_TIMEOUT_VALUE "30" // timeout from on to dim
#define LCD_OFF_TIMEOUT_VALUE "10" // timeout from dim to off
#define LCD_DIM_BRIGHTNESS_VALUE "10" // percent of max brightness

#define array_size(a) (sizeof(a) / sizeof(a[0]))

static char *tc_keys[] = {
	UI_CONF_KEY,
	DISK_CONFIG_KEY,
	PUSH_DIR_KEY,
	ROOTFS_KEY,
	ENABLE_NFS_KEY,
	NFSURL_KEY,
	DISK_FORCE_KEY,
	BAT_THRESHOLD_KEY,
	LCD_DIM_TIMEOUT_KEY,
	LCD_OFF_TIMEOUT_KEY,
	LCD_DIM_BRIGHTNESS_KEY,
	NULL,
};

static char *tc_values[] = {
	UI_CONF_VALUE,
	DISK_CONFIG_VALUE,
	PUSH_DIR_VALUE,
	ROOTFS_VALUE,
	ENABLE_NFS_VALUE,
	NFSURL_VALUE,
	DISK_FORCE_VALUE,
	BAT_THRESHOLD_VALUE,
	LCD_DIM_TIMEOUT_VALUE,
	LCD_OFF_TIMEOUT_VALUE,
	LCD_DIM_BRIGHTNESS_VALUE,
	NULL,
};

static Hashmap *tboot_config;

char *tboot_config_get(char *key)
{
	if (!tboot_config) {
		pr_error("tboot config wasn't init.\n");
		return NULL;
	}

	if (!hashmapContainsKey(tboot_config, (void *)key)) {
		pr_error("invalid tboot config keyword:%s\n", key);
		return NULL;
	}

	return hashmapGet(tboot_config, (void *)key);
}

char *tboot_config_set(char *key, char *value)
{
	int i;
	int valid_key;

	if (!tboot_config) {
		pr_error("tboot config wasn't init.\n");
		return NULL;
	}

	valid_key = 0;
	for (i = 0; tc_keys[i]; i++) {
		if (!strcmp(key, tc_keys[i])) {
			valid_key = 1;
			break;
		}
	}

	if (!valid_key) {
		pr_error("invalid tboot config keyword:%s\n", key);
		return NULL;
	}

	return hashmapPut(tboot_config, (void *)key, (void *)value);
}

void tboot_config_dump(void)
{
	int i;

	printf("==== tboot config ====\n");
	for (i = 0; tc_keys[i]; i++)
		printf("%s : %s\n", tc_keys[i], tboot_config_get(tc_keys[i]));
}

void tboot_config_keywords(void)
{
	int i;

	if (!tboot_config) {
		pr_error("tboot config wasn't init.\n");
		return;
	}

	fastboot_info("\n");
	fastboot_info("Keyword             Current value\n");
	fastboot_info("---------------------------------\n");
	for (i = 0; tc_keys[i]; i++) {
		char *buf;
		int len = 0;
		int left = 0;
		if (asprintf(&buf, "%-20s%s\n", tc_keys[i],
					tboot_config_get(tc_keys[i])) == -1)
			continue;
		fastboot_info(buf);
		free(buf);
	}
	fastboot_info("\n");
	fastboot_okay("");
}

static int load_config(const char *config)
{
	struct config_parser *cp;
	char *value;
	int i;

	if (!config || strlen(config) == 0)
		cp = config_parser_init(TBOOT_CONFIG);
	else
		cp = config_parser_init(config);

	if (!cp)
		goto err;

	/* init config with default values */
	tboot_config = hashmapCreate(array_size(tc_keys), strhash, strcompare);
	if (!tboot_config)
		goto err;

	for (i = 0; tc_keys[i]; i++)
		hashmapPut(tboot_config, (void *)tc_keys[i], (void *)tc_values[i]);

	/* parse config file */
	value = config_parser_get(cp, UI_CONF_KEY);
	if (value)
		tboot_config_set(UI_CONF_KEY, value);

	value = config_parser_get(cp, DISK_CONFIG_KEY);
	if (value)
		tboot_config_set(DISK_CONFIG_KEY, value);

	value = config_parser_get(cp, PUSH_DIR_KEY);
	if (value)
		tboot_config_set(PUSH_DIR_KEY, value);

	value = config_parser_get(cp, ROOTFS_KEY);
	if (value)
		tboot_config_set(ROOTFS_KEY, value);

	value = config_parser_get(cp, ENABLE_NFS_KEY);
	if (value)
		tboot_config_set(ENABLE_NFS_KEY, value);

	value = config_parser_get(cp, NFSURL_KEY);
	if (value)
		tboot_config_set(NFSURL_KEY, value);

	value = config_parser_get(cp, DISK_FORCE_KEY);
	if (value)
		tboot_config_set(DISK_FORCE_KEY, value);

	value = config_parser_get(cp, BAT_THRESHOLD_KEY);
	if (value)
		tboot_config_set(BAT_THRESHOLD_KEY, value);

	value = config_parser_get(cp, LCD_DIM_TIMEOUT_KEY);
	if (value)
		tboot_config_set(LCD_DIM_TIMEOUT_KEY, value);

	value = config_parser_get(cp, LCD_OFF_TIMEOUT_KEY);
	if (value)
		tboot_config_set(LCD_OFF_TIMEOUT_KEY, value);

	value = config_parser_get(cp, LCD_DIM_BRIGHTNESS_KEY);
	if (value)
		tboot_config_set(LCD_DIM_BRIGHTNESS_KEY, value);

	config_parser_free(cp);
	tboot_config_dump();
	return 0;

err:
	if (cp)
		config_parser_free(cp);
	if (tboot_config)
		hashmapFree(tboot_config);
	return -1;
}

static void lcd_state_init(void)
{
	lcd_state = (lcd_state_t)lcd_state_on;
	RESET_ALARM;
}

static void *sig_handler(void *arg)
{
	sigset_t *set = NULL;
	int sig = -1;

	if (arg == NULL)
		return NULL;

	set = (sigset_t *)arg;
	while (1) {
		if (sigwait(set, &sig))
			pr_critial("sigwait failed.\n");
		else
			pr_debug("signal: %d recorded.\n", sig);
		switch (sig) {
			/*
			 * capture SIGPIPE, otherwise the process will be killed if
			 * pipe broken when the image is too large
			 *
			 * If the image is too large larger than partition size + buffer size.
			 * because there is still something left in usb buffer to read, so we
			 * can't write back fail mesg. It will hang there.
			 *
			 * So the simplest way to resolve this is read and discard.
			 */
			case SIGPIPE:
				pr_debug("pipe broken\n");
				pipe_broken = 1;
				break;
			case SIGALRM:
				if (is_fastboot_active()) {
					pr_debug("fastboot is active.\n");
					continue;
				}
				lcd_state = (lcd_state_t)lcd_state(LCD_IDLE);
				if (lcd_state == lcd_state_dim)
					alarm(atoi(tboot_config_get(LCD_OFF_TIMEOUT_KEY)));
				break;
			default:
				pr_debug("received unhandled signal: %d\n", sig);
				break;
		}
	}
	return NULL;
}

int main(int argc, char **argv)
{
	pthread_t t_auto, t_input, t_uevent, t_sighandler;
	//Volume *vol;
	int ret;
	char *disk_conf;
	void (*ui_update)(void *) = NULL;
	sigset_t set;

	/* block signals for all theads */
	sigemptyset(&set);
	sigaddset(&set, SIGPIPE);
	sigaddset(&set, SIGALRM);
	if (pthread_sigmask(SIG_BLOCK, &set, NULL))
		pr_critial("block signal failed.\n");

	/* create a dedicate thread to handle signals */
	if (pthread_create(&t_sighandler, NULL, sig_handler, &set))
		pr_critial("create signal handler thread failed.\n");

	if (argc > 1)
		ret = load_config(argv[1]);
	else
		ret = load_config(NULL);
	/* currently, missing config file is not critical */
	if (ret)
		pr_warning("can't load tboot configuration.\n");

	if (ret = tboot_ui_init(tboot_config_get(UI_CONF_KEY)))
		pr_error("UI crashed!\n");

	tboot_config_set(UI_CONF_KEY, tboot_ui_getconfpath());

	ev_init(input_callback, NULL);

	display_sysinfo(ret);

	if (!ret) {
		ui_update = ui_callback;
	}

	pr_info(" -- preos v%s for %s --\n", preos_version, DEVICE_NAME);
	import_kernel_cmdline(parse_cmdline_option);

	disk_conf = tboot_config_get(DISK_CONFIG_KEY);
	if (!disk_conf) {
		pr_error("Invalid tboot config disk_conf.\n");
		die();
	}

	setup_disk_information(disk_conf);

	aboot_register_commands();

	register_tboot_plugins();

	if (pthread_create(&t_input, NULL, input_listener_thread,
					NULL)) {
		pr_perror("pthread_create");
		die();
	}

	lcd_state_init();

	if (pthread_create(&t_uevent, NULL, uevent_thread, ui_update)) {
		pr_perror("pthread_create t_uevent");
		die();
	}

	/*
	vol = volume_for_path(SDCARD_VOLUME);
	if (vol)
		try_update_sw(vol, 1);
	*/

	if (g_use_autoboot && !g_update_location) {
		/*
		 * Create menu items for debug boot, this is a feature for developers
		 * only.
		 *
		 * Developers (kernel developers) put kernel, cmdline,
		 * rmadisk.img(optional) to platform boot directory  in kexec enabled
		 * preos.
		 *
		 * Generally, there are two ways to do that.
		 *
		 * 1. you can put these files into /boot after the system boot
		 * into rootfs.
		 * 2. you can put these files into platform.img.gz and create a new
		 * platform.img.gz and then flash it to target device.
		 *
		 * Previous, if the system can't boot into rootfs, the only way left
		 * is flash a new platform image. Apparently, it's a huge effort.
		 *
		 * To make more choice, two kernels are supported now, so make sure
		 * there is a works kernel in /boot , you can always boot into
		 * normal system and put a new kernel by any other way, such as scp,
		 * ftp and etc.
		 */

		/*
		 * make our menu acts more like grub which more users familiar with.
		 */
		tboot_ui_menu_item("Boot: kernel", start_default_kernel);
		tboot_ui_menu_item("Boot: kernel.bak", start_backup_kernel);
		tboot_ui_menu_item("Boot: kernel/rootfs on TF/micro-SD card",
				start_mmc_kernel);
		/*
		 * boot from NFS is quite useless now because the usb network bandwidth
		 * is too narrow to satisfy the boot up sequence. It may (80%) hang at
		 * system boot up, especially at X server start up
		 *
		 * So, by default, disable it.
		 */
		if (strcasecmp(tboot_config_get(ENABLE_NFS_KEY), "yes") == 0)
			tboot_ui_menu_item("Boot: kernel/rootfs on NFS",
					start_nfs_kernel);

		tboot_ui_menu_selected(3);      // set debug boot: kernel selected

		if (pthread_create(&t_auto, NULL, autoboot_thread, NULL)) {
			pr_perror("pthread_create");
			die();
		}
	}

	/*
	 * dealy to start tboot server
	 */
	do {
		sleep(1);
	} while (autoboot_enabled || power_pressed);

	pr_info("Listening for the fastboot protocol over USB.\n");
	fastboot_init(g_scratch_size * MEGABYTE);

	/* Shouldn't get here */
	tboot_ui_exit();

	if (tboot_config)
		hashmapFree(tboot_config);
//	tboot_cmds_free();

	exit(1);
}
